/* @flow */

declare type SourceTokenListIndexRange = [SourceTokenListIndex, SourceTokenListIndex];

declare class SourceType {
  name: string;
  constructor(name: string): void;
  toString(): string;
}

declare class SourceToken {
  type: SourceType;
  start: number;
  end: number;
  constructor(type: SourceType, start: number, end: number): void;
}

declare class SourceTokenListIndex {
  constructor(sourceTokenList: SourceTokenList, index:number): void;
  advance(offset: number): ?SourceTokenListIndex;
  next(): ?SourceTokenListIndex;
  previous(): ?SourceTokenListIndex;
  isBefore(other: SourceTokenListIndex): boolean;
  isAfter(other: SourceTokenListIndex): boolean;
  compare(other: SourceTokenListIndex): number;
  distance(other: SourceTokenListIndex): number;
}

declare class SourceTokenList {
  length: number;
  startIndex: SourceTokenListIndex;
  endIndex: SourceTokenListIndex;
  constructor(tokens: Array<SourceToken>): void;
  forEach(iterator: (token: SourceToken, index: SourceTokenListIndex, list: SourceTokenList) => void): void;
  map<T>(mapper: (token: SourceToken, index: SourceTokenListIndex, list: SourceTokenList) => T): Array<T>;
  filter(predicate: (token: SourceToken, index: SourceTokenListIndex, list: SourceTokenList) => boolean): SourceTokenList;
  slice(start: SourceTokenListIndex, end: SourceTokenListIndex): SourceTokenList;
  tokenAtIndex(index: SourceTokenListIndex): ?SourceToken;
  rangeOfInterpolatedStringTokensContainingTokenIndex(index: SourceTokenListIndex): ?SourceTokenListIndexRange;
  rangeOfMatchingTokensContainingTokenIndex(startType: SourceType, endType: SourceType, index: SourceTokenListIndex): ?SourceTokenListIndexRange;
  indexOfTokenContainingSourceIndex(index: number): ?SourceTokenListIndex;
  indexOfTokenStartingAtSourceIndex(index: number): ?SourceTokenListIndex;
  indexOfTokenEndingAtSourceIndex(index: number): ?SourceTokenListIndex;
  indexOfTokenMatchingPredicate(predicate: (token: SourceToken) => boolean, start?: ?SourceTokenListIndex): ?SourceTokenListIndex;
  lastIndexOfTokenMatchingPredicate(predicate: (token: SourceToken) => boolean, start?: ?SourceTokenListIndex): ?SourceTokenListIndex;
  toArray(): Array<SourceToken>;
}

declare class SourceLocation {
  type: SourceType;
  index: number;
  constructor(type: SourceType, index: number): void;
}

declare function lex(source: string): SourceTokenList;
declare function consumeStream(lexer: () => SourceLocation): Array<SourceLocation>;


declare var AT: SourceType;
declare var BOOL: SourceType;
declare var BREAK: SourceType;
declare var CATCH: SourceType;
declare var CALL_END: SourceType;
declare var CALL_START: SourceType;
declare var CLASS: SourceType;
declare var COLON: SourceType;
declare var COMMA: SourceType;
declare var COMMENT: SourceType;
declare var CONTINUATION: SourceType;
declare var CONTINUE: SourceType;
declare var DELETE: SourceType;
declare var DO: SourceType;
declare var DOT: SourceType;
declare var DSTRING_END: SourceType;
declare var DSTRING_START: SourceType;
declare var ELSE: SourceType;
declare var EOF: SourceType;
declare var EXISTENCE: SourceType;
declare var FINALLY: SourceType;
declare var FOR: SourceType;
declare var FUNCTION: SourceType;
declare var HERECOMMENT: SourceType;
declare var HEREGEXP_END: SourceType;
declare var HEREGEXP_START: SourceType;
declare var IF: SourceType;
declare var INTERPOLATION_START: SourceType;
declare var INTERPOLATION_END: SourceType;
declare var JS: SourceType;
declare var LBRACE: SourceType;
declare var LBRACKET: SourceType;
declare var LOOP: SourceType;
declare var LPAREN: SourceType;
declare var NEWLINE: SourceType;
declare var NORMAL: SourceType;
declare var NULL: SourceType;
declare var NUMBER: SourceType;
declare var OPERATOR: SourceType;
declare var OWN: SourceType;
declare var PROTO: SourceType;
declare var RANGE: SourceType;
declare var REGEXP: SourceType;
declare var RBRACE: SourceType;
declare var RBRACKET: SourceType;
declare var RELATION: SourceType;
declare var RETURN: SourceType;
declare var RPAREN: SourceType;
declare var SEMICOLON: SourceType;
declare var SPACE: SourceType;
declare var SUPER: SourceType;
declare var SWITCH: SourceType;
declare var SSTRING_END: SourceType;
declare var SSTRING_START: SourceType;
declare var STRING_CONTENT: SourceType;
declare var STRING_LINE_SEPARATOR: SourceType;
declare var STRING_PADDING: SourceType;
declare var TDSTRING_END: SourceType;
declare var TDSTRING_START: SourceType;
declare var THEN: SourceType;
declare var THIS: SourceType;
declare var TRY: SourceType;
declare var TSSTRING_END: SourceType;
declare var TSSTRING_START: SourceType;
declare var UNDEFINED: SourceType;
declare var UNKNOWN: SourceType;
declare var WHEN: SourceType;
declare var WHILE: SourceType;
declare var IDENTIFIER: SourceType;
declare var YIELD: SourceType;
declare var YIELDFROM: SourceType;


export {
  lex as default,
  consumeStream,
  SourceLocation,
  SourceToken,
  SourceTokenList,
  SourceTokenListIndex,
  SourceType,
  AT,
  BOOL,
  BREAK,
  CATCH,
  CALL_END,
  CALL_START,
  CLASS,
  COLON,
  COMMA,
  COMMENT,
  CONTINUATION,
  CONTINUE,
  DELETE,
  DO,
  DOT,
  DSTRING_END,
  DSTRING_START,
  ELSE,
  EOF,
  EXISTENCE,
  FINALLY,
  FOR,
  FUNCTION,
  HERECOMMENT,
  HEREGEXP_END,
  HEREGEXP_START,
  IF,
  INTERPOLATION_START,
  INTERPOLATION_END,
  JS,
  LBRACE,
  LBRACKET,
  LOOP,
  LPAREN,
  NEWLINE,
  NORMAL,
  NULL,
  NUMBER,
  OPERATOR,
  OWN,
  PROTO,
  RANGE,
  REGEXP,
  RBRACE,
  RBRACKET,
  RELATION,
  RETURN,
  RPAREN,
  SEMICOLON,
  SPACE,
  SUPER,
  SWITCH,
  SSTRING_END,
  SSTRING_START,
  STRING_CONTENT,
  STRING_LINE_SEPARATOR,
  STRING_PADDING,
  TDSTRING_END,
  TDSTRING_START,
  TSSTRING_END,
  TSSTRING_START,
  THEN,
  THIS,
  TRY,
  UNDEFINED,
  UNKNOWN,
  WHEN,
  WHILE,
  IDENTIFIER,
  YIELD,
  YIELDFROM,
};
